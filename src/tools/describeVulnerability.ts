import { z } from "zod";
import type { ToolCallback } from "@modelcontextprotocol/sdk/server/mcp.js";

export const describeVulnerabilitySchema = z.object({
  cve: z.string().describe("CVE ID (e.g., CVE-2024-2700). This must be obtained from analyze_dependency_vulnerabilities first - you cannot use manifestPath here."),
  packageRef: z.object({
    purl: z.url().describe("Dependency purl to identify the package (e.g., pkg:maven/org.postgresql/postgresql@42.7.1). This must be obtained from analyze_dependency_vulnerabilities first."),
    scope: z.enum(["runtime", "development", "test", "build"]).describe("Dependency scope"),
    dependency_graph: z.array(z.url()).describe("Dependency graph representing the parent dependencies of the package in case it is a transitive dependency"),
  }),
});

interface VulnerabilityDescription {
  assessment: any;
}

async function describeVulnerability(
  intelServerUrl: string,
  cve: string,
  packageRef: {
    purl: string,
    scope: "runtime" | "development" | "test" | "build",
    dependency_graph: string[],
  },
): Promise<VulnerabilityDescription> {
  const url = `${intelServerUrl}/v1/vulnerability/assessment`;
  
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      cve,
      package: packageRef,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text().catch(() => response.statusText);
    throw new Error(`Failed to describe vulnerability: ${response.status} ${response.statusText} - ${errorText}`);
  }

  const data = await response.json() as { assessment: any };
  return {
    assessment: data.assessment,
  };
}

export function createDescribeVulnerabilityTool(
  intelServerUrl: string,
): ToolCallback<typeof describeVulnerabilitySchema> {
  return async (args, _extra) => {
    try {
      const { cve, packageRef } = args;
      
      // Validate that required parameters are present
      if (!cve || !packageRef) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                error: "Missing required parameters: cve and packageRef are required. This tool requires specific vulnerability details obtained from analyze_dependency_vulnerabilities. You cannot use manifestPath here - first call analyze_dependency_vulnerabilities with your manifestPath, then use the cve and packageRef from those results.",
                hint: "Workflow: 1) Call analyze_dependency_vulnerabilities with manifestPath 2) Extract cve and packageRef from results 3) Call explain_vulnerability with those values",
              }, null, 2),
            },
          ],
          isError: true,
        };
      }
      
      // Fetch assessment from backend
      const assessmentResult = await describeVulnerability(
        intelServerUrl,
        cve,
        packageRef,
      );

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(assessmentResult.assessment, null, 2),
          },
        ],
      };
    } catch (error: any) {
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: error.message || "Failed to describe vulnerability",
            }, null, 2),
          },
        ],
        isError: true,
      };
    }
  };
}

